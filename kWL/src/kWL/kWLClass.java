package kWL;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NavigableSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import datastructure.IndexedTreeSet;
import datastructure.IndexedTreeMap2;
import exceptions.InvalidPermutationException;
import group.data.Colour;
import group.data.InitialColour;
import group.data.Pair;

/**
 * This contains the implementation of the kWL method for group isomorphism.
 * kWL() and kWLinv() are almost the same thing, the first is used to compare between 2 groups and the other
 * to generate data about a group alone.
 * The usage of these methods is outlined in the current scrappy main method (as code)
 * as well as in the commented out main method.
 * Make sure the file "1.g" is in the project folder or in the working directory while running the main
 * method of this class.
 * 
 * @author Karim Elsheikh
 */
public class kWLClass {
	
	static FileWriter csvWriter;
	static long startTime;
	static long endTime;
	static long duration;
	static boolean flag;
	static int rounds;
	static int rounds2;
	static int globalCounter;
	static int numberOfColourClasses1;
	static int numberOfColourClasses2;
	static int globalOrder;
	static ArrayListComparator arrayListComparator = new ArrayListComparator();
	static String s;
	
	/**
	 * Returns a Pair.
	 * The Pair contains ArrayList<Integer[]> genBy that stores for each
	 * element in the group a minimum sequence of generators that generate this element
	 * where the generators are prioritised in the order given.
	 * The generators are referred to as 1-based indices.
	 * The Pair additionally contains Integer[][] yield, that has (length of generators) many
	 * rows, and in each row there is (Order of group - 1) integers, which are the indices of
	 * elements that result from the multiplication of each element in the group
	 * (except the identity) by the ith generator.
	 * The elements are also referred to as 1-based indices.
	 * 
	 * generatedByAndYields below is the actual method used by this kWL implementation,
	 * the generators are passed as indices along with a reference to the whole group.
	 */
	public static InitialColour generatedByAndYields(Permutation[] generators, int degree) {
		TreeMap<Permutation, Integer> orbitMap = new TreeMap<Permutation, Integer>();
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		ArrayList<Integer[]> genBy = new ArrayList<Integer[]>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitMap.put(identity, 1);
		orbit.add(identity);
		genBy.add(new Integer[0]); // Integer array of length 0 denoting the generation of the empty element
		
		for (int i = 0; i < generators.length; i++) {
			orbit.add(generators[i]);
			orbitMap.put(generators[i], orbit.size());
			genBy.add(new Integer[] {i+1}); // Integer array containing only the 1-based index (i+1)
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (int j = 0; j < generators.length; j++) {
				t = orbit.get(i).multiply(generators[j]);
				if (!orbitMap.containsKey(t)) {
					orbit.add(t);
					orbitMap.put(t, orbit.size());
					genBy.add(Helpers.copyAndAdd(genBy.get(i), j+1)); // New element is generated by the sequence genBy[i] ○ (j+1)
				}
			}
		}
		
		Integer[][] yield = new Integer[generators.length][orbit.size()-1];
		for (int i = 0; i < generators.length; i++) {
			for (int j = 1; j < orbit.size(); j++) {
				yield[i][j-1] = orbitMap.get(orbit.get(j).multiply(generators[i]));
			}
		}
		
		return new InitialColour(genBy, yield);
	}
	
	/**
	 * Same as above, except it uses the ArrayList indices to access the generators from the group.
	 */
	public static InitialColour generatedByAndYields(Permutation[] group, ArrayList<Integer> indices, int degree) {
		TreeMap<Permutation, Integer> orbitMap = new TreeMap<Permutation, Integer>();
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		ArrayList<Integer[]> genBy = new ArrayList<Integer[]>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitMap.put(identity, 1);
		orbit.add(identity);
		genBy.add(new Integer[0]); // Integer array of length 0 denoting the generation of the empty element
		
		for (int i = 0; i < indices.size(); i++) {
			orbit.add(group[indices.get(i)]);
			orbitMap.put(group[indices.get(i)], orbit.size());
			genBy.add(new Integer[] {i+1}); // Integer array containing only the 1-based index (i+1)
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (int j = 0; j < indices.size(); j++) {
				t = orbit.get(i).multiply(group[indices.get(j)]);
				if (!orbitMap.containsKey(t)) {
					orbit.add(t);
					orbitMap.put(t, orbit.size());
					genBy.add(Helpers.copyAndAdd(genBy.get(i), j+1)); // New element is generated by the sequence genBy[i] ○ (j+1)
				}
			}
		}
		
		Integer[][] yield = new Integer[indices.size()][orbit.size()-1];
		for (int i = 0; i < indices.size(); i++) {
			for (int j = 1; j < orbit.size(); j++) {
				yield[i][j-1] = orbitMap.get(orbit.get(j).multiply(group[indices.get(i)]));
			}
		}
		
		return new InitialColour(genBy, yield);
	}
	
	/**
	 * Generates the whole group from the given array of generators.
	 */
	public static Permutation[] generate(Permutation[] generators, int degree) {
		TreeSet<Permutation> orbitSet = new TreeSet<Permutation>(); 
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitSet.add(identity);
		orbit.add(identity);
		
		for (Permutation s : generators) {
			orbitSet.add(s);
			orbit.add(s);
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (Permutation s : generators) {
				t = orbit.get(i).multiply(s);
				
				if (!orbitSet.contains(t)) {
					orbitSet.add(t);
					orbit.add(t);
				}
			}
		}
		
		return orbit.toArray(new Permutation[orbit.size()]);
	}
	
	public static boolean compareColours(IndexedTreeMap2<Integer> C1, IndexedTreeMap2<Integer> C2, int p, boolean converges) {
		NavigableSet<Integer> keySet1 = C1.navigableKeySet();
		NavigableSet<Integer> keySet2 = C2.navigableKeySet();
		
		if (keySet1.size() != keySet2.size()) {
			if (converges) {
				System.out.print("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
				   + "Colour sets don't have the same size");
			}
			else {
				System.out.print("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
		    	+ "Colour sets don't have the same size");
			}
		    System.out.println(" (" + keySet1.size() + " and " + keySet2.size() + ").");
			rounds2 = p;
			numberOfColourClasses1 = keySet1.size();
			numberOfColourClasses2 = keySet2.size();
		    return false;
		}
		
		if (!keySet1.equals(keySet2)) {
			if (converges) {
				System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size (" + keySet1.size() + "), but don't have the same colours.");
			}
			else {
				System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size (" + keySet1.size() + "), but don't have the same colours.");
			}
			rounds2 = p;
			numberOfColourClasses1 = keySet1.size();
			numberOfColourClasses2 = keySet2.size();
		    return false;
		}
		
		Iterator<Integer> it1 = keySet1.iterator();
		Iterator<Integer> it2 = keySet2.iterator();
		int cn = 0;
		while (it1.hasNext()) {
			Integer t1 = it1.next(), t2 = it2.next();
			
			if (!C1.get(t1).equals(C2.get(t2))) {
				if (converges) {
					System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, but Colours #" + cn + "'s counts are not equal.");
				}
				else {
					System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, but Colours #" + cn + "'s counts are not equal.");
				}
				rounds2 = p;
				numberOfColourClasses1 = keySet1.size();
				numberOfColourClasses2 = keySet2.size();
				return false;
			}
			
			cn++;
		}
		
		rounds2 = p;
		numberOfColourClasses1 = keySet1.size();
		numberOfColourClasses2 = keySet2.size();
		return true;
	}
	
	public static boolean kWL(Permutation[] S1, Permutation[] S2, int degree1, int degree2) {
		Permutation[] G1, G2;
		G1 = generate(S1, degree1);
		G2 = generate(S2, degree2);
		
		if (G1.length != G2.length) {
			System.out.println("Non-isomorphic: Orders of the two groups when fully generated are not equal.");
			System.out.println(G1.length + " and " + G2.length);
			rounds2 = 0;
			numberOfColourClasses1 = -1;
			numberOfColourClasses2 = -1;
			return false;
		}
		int order = G1.length;
		int p = 0;
		
		// Maps from pair of indices to Pair (colour in Round 0)
		TreeMap<ArrayList<Integer>, InitialColour> E1 = new TreeMap<ArrayList<Integer>, InitialColour> (arrayListComparator);
		TreeMap<ArrayList<Integer>, InitialColour> E2 = new TreeMap<ArrayList<Integer>, InitialColour> (arrayListComparator);
		
		// Set containing all different Pairs, to allow mapping colours to integers
		IndexedTreeSet<InitialColour> uniqueInitialColours = new IndexedTreeSet<InitialColour>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> C1 = new IndexedTreeMap2<Integer>();
		IndexedTreeMap2<Integer> C2 = new IndexedTreeMap2<Integer>();
		
		// Maps from pair of indices to colour index
		TreeMap<ArrayList<Integer>, Integer> M1 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
		TreeMap<ArrayList<Integer>, Integer> M2 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
		
		// Round 0
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				InitialColour X1 = generatedByAndYields(G1, A1, degree1);
				InitialColour X2 = generatedByAndYields(G2, A2, degree2);
				
				uniqueInitialColours.add(X1);
				uniqueInitialColours.add(X2);
				
				E1.put(A1, X1);
				E2.put(A2, X2);
			}
		}
		
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				InitialColour X1 = E1.get(A1);
				InitialColour X2 = E2.get(A2);
				
				Integer t1 = uniqueInitialColours.entryIndex(X1);
				Integer t2 = uniqueInitialColours.entryIndex(X2);
				
				C1.increment(t1);
				C2.increment(t2);
				
				M1.put(A1, t1);
				M2.put(A2, t2);
			}
		}
		// End of Round 0
		
		System.out.println("Round " + 0 + ":");
		System.out.println("Number of unique Colour Classes (in both Groups): " + uniqueInitialColours.size());
		if (!compareColours(C1, C2, p, false)) {
			rounds2 = p;
			return false;
		}
		
		// Maps from pair of indices to Colour (colour starting from Round 1)
		TreeMap<ArrayList<Integer>, Colour> F1 = new TreeMap<ArrayList<Integer>, Colour> (arrayListComparator);
		TreeMap<ArrayList<Integer>, Colour> F2 = new TreeMap<ArrayList<Integer>, Colour> (arrayListComparator);
		
		// Set containing all different Colours, to allow mapping Colours to integers
		IndexedTreeSet<Colour> uniqueColours = new IndexedTreeSet<Colour>();
		
		// Maps the old colour's index to the new colour's index, used to check convergence
		TreeMap<Integer, Integer> colourIndexToNewIndex1 = new TreeMap<Integer, Integer>();
		TreeMap<Integer, Integer> colourIndexToNewIndex2 = new TreeMap<Integer, Integer>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the >new< colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> D1;
		IndexedTreeMap2<Integer> D2;
		
		// Maps from pair of indices to >new< colour index
		TreeMap<ArrayList<Integer>, Integer> N1;
		TreeMap<ArrayList<Integer>, Integer> N2;
		
		boolean converges1 = false;
		boolean converges2 = false;
		
		// Start of Rounds ≥ 1
		for (p = 1; p <= rounds; p++) {
			converges1 = true;
			converges2 = true;
			
			D1 = new IndexedTreeMap2<Integer>();
			D2 = new IndexedTreeMap2<Integer>();
			N1 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
			N2 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
			
			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					// IndexedTreeMap<Integer, Integer> with increment
					IndexedTreeMap2<Pair> t1 = new IndexedTreeMap2<Pair>();
					IndexedTreeMap2<Pair> t2 = new IndexedTreeMap2<Pair>();
					for (int k = 1; k < order; k++) {
						if (k != i && k != j) {
							ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(k, j));
							ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, k));
							t1.increment(new Pair(M1.get(A1), M1.get(A2)));
							t2.increment(new Pair(M2.get(A1), M2.get(A2)));
						}
					}
					
					ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Colour c1 = new Colour(M1.get(A), t1);
					Colour c2 = new Colour(M2.get(A), t2);
					
					F1.put(A, c1);
					F2.put(A, c2);
					
					uniqueColours.add(c1);
					uniqueColours.add(c2);
				}
			}
			
			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Integer c1_index = uniqueColours.entryIndex(F1.get(A));
					Integer c2_index = uniqueColours.entryIndex(F2.get(A));
					
					if (converges1) {
						Integer temp = colourIndexToNewIndex1.put(M1.get(A), c1_index);
						if (temp != null && !temp.equals(c1_index)) {
							converges1 = false;
						}
					}
					if (converges2) {
						Integer temp = colourIndexToNewIndex2.put(M2.get(A), c2_index);
						if (temp != null && !temp.equals(c2_index)) {
							converges2 = false;
						}
					}
					
					N1.put(A, c1_index);
					N2.put(A, c2_index);
					D1.increment(c1_index);
					D2.increment(c2_index);
				}
			}
			
			System.out.println("Round " + p + ":");
			System.out.println("Number of unique Colour Classes (in both Groups): " + uniqueColours.size());
			if (!compareColours(D1, D2, p, converges1 && converges2)) {
				rounds2 = p;
				return false;
			}
			
			// Cleanup at the end of a round
			colourIndexToNewIndex1.clear();
			colourIndexToNewIndex2.clear();
			uniqueColours.clear();
			
			M1.clear();
			M2.clear();
			M1 = N1; // new colours will now be the old colours
			M2 = N2;
			
			C1.clear();
			C2.clear();
			C1 = D1; // new colours will now be the old colours
			C2 = D2;
			
			F1.clear();
			F2.clear();
			if (converges1 && converges2)
				break;
		}
		// End of Rounds ≥ 1
		
		if (!converges1 || !converges2)
			p--;
		
		if (converges1 && converges2) {
			System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		else {
			System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		
		rounds2 = p;
		return true;
	}
	
	public static boolean kWLinv(Permutation[] S, int degree, int index) throws IOException {
		Permutation[] G;
		G = generate(S, degree);
		
		int order = G.length;
		int p = 0;
		
		// Maps from pair of indices to Pair (colour in Round 0)
		TreeMap<ArrayList<Integer>, InitialColour> E = new TreeMap<ArrayList<Integer>, InitialColour> (arrayListComparator);
		
		// Set containing all different Pairs, to allow mapping colours to integers
		IndexedTreeSet<InitialColour> uniqueInitialColours = new IndexedTreeSet<InitialColour>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> C = new IndexedTreeMap2<Integer>();
		
		// Maps from pair of indices to colour index
		TreeMap<ArrayList<Integer>, Integer> M = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
		
		// Round 0
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
				
				InitialColour X = generatedByAndYields(G, A, degree);
				
				uniqueInitialColours.add(X);
				
				E.put(A, X);
			}
		}
		
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
				
				InitialColour X = E.get(A);
				
				Integer t = uniqueInitialColours.entryIndex(X);
				
				C.increment(t);
				
				M.put(A, t);
			}
		}
		// End of Round 0
		createDirectory("C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + "0");
		List<String> lines = Arrays.asList("" + C.keySet().size());
		Path file = Paths.get("C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + "0\\numberOfColourClasses.txt");
		Files.write(file, lines, StandardCharsets.UTF_8);
		writeObjectToFile(uniqueInitialColours, "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + "0\\uniqueInitialColours");
		writeObjectToFile(C, "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + "0\\C");
		
		// System.out.println("Round " + 0 + ":");
		// System.out.println("Number of unique Colour Classes: " + uniqueInitialColours.size());
		
		// Maps from pair of indices to Colour (colour starting from Round 1)
		TreeMap<ArrayList<Integer>, Colour> F = new TreeMap<ArrayList<Integer>, Colour> (arrayListComparator);
		
		// Set containing all different Colours, to allow mapping Colours to integers
		IndexedTreeSet<Colour> uniqueColours = new IndexedTreeSet<Colour>();
		
		// Maps the old colour's index to the new colour's index, used to check convergence
		TreeMap<Integer, Integer> colourIndexToNewIndex = new TreeMap<Integer, Integer>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the >new< colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> D;
		
		// Maps from pair of indices to >new< colour index
		TreeMap<ArrayList<Integer>, Integer> N;
		
		boolean converges = false;
		
		// Start of Rounds ≥ 1
		for (p = 1; p <= rounds; p++) {
			converges = true;
			
			D = new IndexedTreeMap2<Integer>();
			N = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);

			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					// IndexedTreeMap<Integer, Integer> with increment
					IndexedTreeMap2<Pair> t = new IndexedTreeMap2<Pair>();
					for (int k = 1; k < order; k++) {
						if (k != i && k != j) {
							ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(k, j));
							ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, k));
							t.increment(new Pair(M.get(A1), M.get(A2)));
						}
					}
					
					ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Colour c = new Colour(M.get(A), t);
					
					F.put(A, c);
					
					uniqueColours.add(c);
				}
			}
			
			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					ArrayList<Integer> A = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Integer c_index = uniqueColours.entryIndex(F.get(A));
					
					if (converges) {
						Integer temp = colourIndexToNewIndex.put(M.get(A), c_index);
						if (temp != null && !temp.equals(c_index)) {
							converges = false;
						}
					}
					
					N.put(A, c_index);
					D.increment(c_index);
				}
			}
			
			// System.out.println("Round " + p //+ ":");
			// System.out.println("Number of unique Colour Classes: " + uniqueColours.size());
			
			// Cleanup at the end of a round
			colourIndexToNewIndex.clear();
			uniqueColours.clear();
			
			M.clear();
			M = N; // new colours will now be the old colours
			
			C.clear();
			C = D; // new colours will now be the old colours
			
			createDirectory("C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + p);
			lines = Arrays.asList("" + C.keySet().size());
			file = Paths.get("C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + p + "\\numberOfColourClasses.txt");
			Files.write(file, lines, StandardCharsets.UTF_8);
			writeObjectToFile(uniqueColours, "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + p + "\\uniqueColours");
			writeObjectToFile(C, "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Invariants\\" + globalOrder + "\\" + index + "\\" + '\u0023' + p + "\\C");
			
			F.clear();
			if (converges) {
				rounds2 = p;
				break;
			}
		}
		// End of Rounds ≥ 1
		
		if (!converges)
			p--;
		
		numberOfColourClasses1 = C.keySet().size();
		rounds2 = p;
		
		return true;
	}
	
	public static void parseKWL(String s, int degree1, int degree2, int index1, int index2) throws IOException {
		int i = 3;
		boolean error = false;
		while (true) {
			if (s.charAt(i) =='(') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 1: String format is incorrect");
			return;
		}
		i++;
		
		while (true) {
			if (s.charAt(i) =='[') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 2: String format is incorrect");
			return;
		}
		i++;
		
		int h = i;
		ArrayList<Permutation> a = new ArrayList<Permutation>();
		ArrayList<Permutation> b = new ArrayList<Permutation>();
		int processingInteger = 0;
		boolean processingPerm = false;
		boolean foundOpeningBracket = false;
		boolean doneWithFirstGroup = false;
		
		while (true) {
			if (!foundOpeningBracket) {
				if (s.charAt(i) == '(') {
					foundOpeningBracket = true;
					if (!processingPerm) { // h holds the index of the start of a permutation
						h = i;
						processingPerm = true;
					}
				}
				else if (s.charAt(i) == ',') {
					// For testing
					// System.out.println(h + " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s, h, i, degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s, h, i, degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) == ']') {
					// For testing
					// System.out.println(h //+ " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s, h, i, degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						doneWithFirstGroup = true;
						Pattern pattern = Pattern.compile("[ \t\n\r\0]*,[ \t\n\r\0]*\\[");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end() - 1;
						}
						else {
							error = true;
							break;
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s, h, i, degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						Pattern pattern = Pattern.compile("[ \t\n\r\0]*\\)[ \t\n\r\0]*;?[ \t\n\r\0]*");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end();
							if (i != s.length())
								error = true;
							break;
						}
						else {
							error = true;
							break;
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 0) { // Didn't start processing integer
				if (Character.isDigit(s.charAt(i))) {
					processingInteger = 1;
				}
				else if (s.charAt(i) == ')') {
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 1) { // Started processing integer
				if (Character.isDigit(s.charAt(i))) {
					
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t' || s.charAt(i) == '\n' || s.charAt(i) == '\r' || s.charAt(i) == '\0') {
					processingInteger = 2;
				}
				else {
					error = true;
					break;
				}
			}
			else if (processingInteger == 2) { // Whitespaces after integer
				if (Character.isDigit(s.charAt(i))) {
					error = true;
					break;
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t' || s.charAt(i) == '\n' || s.charAt(i) == '\r' || s.charAt(i) == '\0') {
					
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else {
					error = true;
					break;
				}
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 3: String format is incorrect");
			return;
		}
		
		startTime = System.nanoTime();
		flag = kWL(a.toArray(new Permutation[a.size()]), b.toArray(new Permutation[b.size()]), degree1, degree2);
		endTime = System.nanoTime();
		csvWriter.append("" + index1);
		csvWriter.append(",");
		csvWriter.append("" + index2);
		csvWriter.append(",");
		csvWriter.append("" + flag);
		csvWriter.append(",");
		csvWriter.append("" + rounds2);
		csvWriter.append(",");
		duration = endTime - startTime;
		csvWriter.append("" + duration / 1000000.0);
		csvWriter.append(",");
		csvWriter.append("" + numberOfColourClasses1);
		csvWriter.append(",");
		csvWriter.append("" + numberOfColourClasses2);
		csvWriter.append("\n");
		csvWriter.flush();
	}
	
	public static void parseKWLinv(String s, int degree, int index) throws IOException {
		int i = 6;
		boolean error = false;
		while (true) {
			if (s.charAt(i) =='(') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 1: String format is incorrect");
			return;
		}
		i++;
		
		while (true) {
			if (s.charAt(i) =='[') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 2: String format is incorrect");
			return;
		}
		i++;
		
		int h = i;
		ArrayList<Permutation> a = new ArrayList<Permutation>();
		int processingInteger = 0;
		boolean processingPerm = false;
		boolean foundOpeningBracket = false;
		
		while (true) {
			if (!foundOpeningBracket) {
				if (s.charAt(i) == '(') {
					foundOpeningBracket = true;
					if (!processingPerm) { // h holds the index of the start of a permutation
						h = i;
						processingPerm = true;
					}
				}
				else if (s.charAt(i) == ',') {
					// For testing
					// System.out.println(h //+ " - " + i);
					try {
						a.add(Representation.parsePermutation(s, h, i, degree));
					}
					catch (InvalidPermutationException e) {
						System.out.println(e.getMessage());
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) == ']') {
					// For testing
					// System.out.println(h //+ " - " + i);
					try {
						a.add(Representation.parsePermutation(s, h, i, degree));
					}
					catch (InvalidPermutationException e) {
						System.out.println(e.getMessage());
					}
					
					Pattern pattern = Pattern.compile("[ \t\n\r\0]*\\)[ \t\n\r\0]*;?[ \t\n\r\0]*");
					Matcher m = pattern.matcher(s);
					if (m.find(i+1)) {
						i = m.end();
						if (i != s.length())
							error = true;
						break;
					}
					else {
						error = true;
						break;
					}
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 0) { // Didn't start processing integer
				if (Character.isDigit(s.charAt(i))) {
					processingInteger = 1;
				}
				else if (s.charAt(i) == ')') {
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t' && s.charAt(i) != '\n' && s.charAt(i) != '\r' && s.charAt(i) != '\0') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 1) { // Started processing integer
				if (Character.isDigit(s.charAt(i))) {
					
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t' || s.charAt(i) == '\n' || s.charAt(i) == '\r' || s.charAt(i) == '\0') {
					processingInteger = 2;
				}
				else {
					error = true;
					break;
				}
			}
			else if (processingInteger == 2) { // Whitespaces after integer
				if (Character.isDigit(s.charAt(i))) {
					error = true;
					break;
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t' || s.charAt(i) == '\n' || s.charAt(i) == '\r' || s.charAt(i) == '\0') {
					
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else {
					error = true;
					break;
				}
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error 3: String format is incorrect");
			return;
		}
		
		startTime = System.nanoTime();
		kWLinv(a.toArray(new Permutation[a.size()]), degree, index);
		endTime = System.nanoTime();
		csvWriter.append("" + globalOrder);
		csvWriter.append(",");
		csvWriter.append("" + index);
		csvWriter.append(",");
		csvWriter.append("" + numberOfColourClasses1);
		csvWriter.append(",");
		csvWriter.append("" + rounds2);
		csvWriter.append(",");
		duration = endTime - startTime;
		csvWriter.append("" + duration / 1000000.0);
		csvWriter.append("\n");
		csvWriter.flush();
	}
	
	public static void parse(String s, int degree1, int degree2, int index1, int index2) throws IOException {
		// Comment this next line out in case you want to print the globalCounter
		// System.out.println("Task #" + globalCounter++);
		if (s.length() <= 2) {
			System.out.println("Error 0: String format is incorrect\n");
			return;
		}
		
		if (s.substring(0, 3).equalsIgnoreCase("kWL")) {
			parseKWL(s, degree1, degree2, index1, index2);
		}
	}
	
	public static void parse(String s, int degree, int index) throws IOException {
		// Comment this next line out in case you want to print the globalCounter
		// System.out.println("Task #" + globalCounter++);
		if (s.length() <= 5) {
			System.out.println("Error 0: String format is incorrect\n");
			return;
		}
		
		if (s.substring(0, 6).equalsIgnoreCase("kWLinv")) {
			parseKWLinv(s, degree, index);
		}
	}
	
//	public static void readGroup() throws InterruptedException, IOException {
//		while(true) {
//			Helpers.appendUsingFileOutputStream(s, Helpers.randomize() //+ "\n");
//			TimeUnit.SECONDS.sleep(1);
//			FileInputStream is = new FileInputStream("Stream2.txt");
//			StringBuilder sb = new StringBuilder();
//			int i;
//			sb.append("kWL(");
//			byte[] buffer;
//			
//			do {
//				buffer = new byte[1024];
//				
//				i = is.read(buffer);
//	            sb.append(new String(buffer, "UTF-8"));
//	            
//	        } while (i != -1);
//			is.close();
//			String t = sb.toString().substring(4);
//			sb.append(",");
//			sb.append(t);
//			sb.append(")");
//			parse(sb.toString(), 128, 128);
//		}
//	}
	
	// Any amount of spaces or tab spaces is (should be) allowed.
	// One semicolon is optional
//	public static void main(String[] args) throws IOException, InterruptedException {
//		globalCounter = 1;
//		rounds = 100000000;
//		
//////		Dihedral Group of Order 8, Dihedral Group of Order 8 (renamed)
////		parse("kWL([ (1,2,3,4), (2,4) ],[(5,3,8,6),(3,6)]);", 4, 8);
//////		Dihedral Group of Order 8, DihedralGroup of Order 8 (swapping the generators)
////		parse("kWL([ (1,2,3,4), (2,4) ],[(3  ,  6), ( 5	,		3,8,6)])", 4, 8);
//////		Dihedral Group of Order 8, Quaternion Group of Order 8
////		parse("kWL([ (1,2,3,4), (2,4) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]);", 4, 8);
//////		Quaternion Group of Order 8, Quaternion Group of Order 8
////		parse("kWL([ (6,22,14,30)(10,34,18,26), (6,10,14,18)(22,26,30,34) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]) 	", 34, 8);
//////		Dihedral Group of Order 8, Cyclic Group of Order 8		
////		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2,3,4,5,6,7,8) ]);", 4, 8);
//////		Dihedral Group of Order 8, Z_4 x Z_2	
////		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2,3,4), (5,6) ]);", 4, 6);
//////		Dihedral Group of Order 8, Elementary Abelian Group of order 8
////		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2), (3,4), (5,6) ]);", 4, 6);
//		String s = "Stream.txt";
//		while(true) {
//			Helpers.appendUsingFileOutputStream(s, Helpers.randomize() //+ "\n");
//			TimeUnit.SECONDS.sleep(1);
//			FileInputStream is = new FileInputStream("Stream2.txt");
//			StringBuilder sb = new StringBuilder();
//			int i;
//			sb.append("kWL(");
//			byte[] buffer;
//			
//			do {
//				buffer = new byte[1024];
//				
//				i = is.read(buffer);
//	            sb.append(new String(buffer, "UTF-8"));
//	            
//	        } while (i != -1);
//			is.close();
//			String t = sb.toString().substring(4);
//			sb.append(",");
//			sb.append(t);
//			sb.append(")");
//			parse(sb.toString(), 128, 128);
//		}
//	}
	
//	public static void main(String[] args) throws IOException, InterruptedException {
//		globalCounter = 1;
//		rounds = 100000000;
//		csvWriter = new FileWriter("new.csv");
//		
//		String s = "Stream.txt";
//		int i = 351, j = 276;
//		
//		while (true) {
////			i = Helpers.randomize(); j = Helpers.randomize();
//			Helpers.appendUsingFileOutputStream(s, i + "\n");
//			TimeUnit.SECONDS.sleep(1);
//			FileInputStream is = new FileInputStream("Stream2.txt");
//			StringBuilder sb = new StringBuilder();
//			int y;
//			sb.append("kWL(");
//			byte[] buffer;
//			
//			do {
//				buffer = new byte[1024];
//				
//				y = is.read(buffer);
//	            sb.append(new String(buffer, "UTF-8"));
//	            
//	        } while (y != -1);
//			
//			Helpers.appendUsingFileOutputStream(s, j + "\n");
//			TimeUnit.SECONDS.sleep(1);
//			is = new FileInputStream("Stream2.txt");
//			sb.append(",");
//			
//			do {
//				buffer = new byte[1024];
//				
//				y = is.read(buffer);
//	            sb.append(new String(buffer, "UTF-8"));
//	            
//	        } while (y != -1);
//			is.close();
//			sb.append(")");
//			parse(sb.toString(), 512, 512, i, j);
//		}
//	}
	
	public static void createDirectory(String directoryPath) {
		
		Path path = Paths.get(directoryPath);
		if (!Files.exists(path)) {
			try {
				Files.createDirectories(path);
			} catch (IOException e) {
				// fail to create directory
				e.printStackTrace();
			}
		}
	}
	
	public static void writeObjectToFile(Object serObj, String filepath) {
		
		try {
			
			FileOutputStream fileOut = new FileOutputStream(filepath);
			ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);
			objectOut.writeObject(serObj);
			objectOut.close();
			// System.out.println("The Object  was succesfully written to a file");
			
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	
	public static Object ReadObjectFromFile(String filepath) {
		
		try {
			
			FileInputStream fileIn = new FileInputStream(filepath);
			ObjectInputStream objectIn = new ObjectInputStream(fileIn);
			
			Object obj = objectIn.readObject();
			
			// System.out.println("The Object has been read from the file");
			objectIn.close();
			return obj;
			
		} catch (Exception ex) {
			ex.printStackTrace();
			return null;
		}
	}
	
//	public static void main(String[] args) {
//		IndexedTreeMap2<Integer> a = new IndexedTreeMap2<Integer>();
//		a.put(2, 17);
//		a.put(3, 45);
//        Colour x = new Colour(8, a);
//        String filepath1 = "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Serialized\\testColour1";
//        writeObjectToFile(x, filepath1);
//        
//		a.increment(2);
//		a.increment(2);
//        Colour y = new Colour(4, a);
//        String filepath2 = "C:\\Users\\Karim\\eclipse-workspace\\kWL\\Serialized\\testColour2";
//        writeObjectToFile(y, filepath2);
//        Colour xR = (Colour) ReadObjectFromFile(filepath1);
//        Colour yR = (Colour) ReadObjectFromFile(filepath2);
//        
//        Colour zR = (Colour) ReadObjectFromFile(filepath1);
//        
//        System.out.println(xR.colour);
//        System.out.println(yR.colour);
//        
//        System.out.println(xR.multiSet.get(2) + ", " + yR.multiSet.get(2));
//        System.out.println(xR.multiSet.get(3) + ", " + yR.multiSet.get(3));
//        
//        System.out.println(xR.multiSet == yR.multiSet);
//	}
	
	public static void genearateInvariants(int startOrder, int endOrder, int roundsParam, String CSVfileName, boolean printString) throws IOException, InterruptedException {
		globalCounter = 1;
		rounds = roundsParam;
		csvWriter = new FileWriter(CSVfileName);
		
		String fileReadByGAP = "Stream.txt";
		FileInputStream groupInputStream;
		StringBuilder sb;
		boolean first, flag;
		int j;
		for (int i = startOrder; i <= endOrder; i++) {
			globalOrder = i;
			if (i != 256) j = 1;
			else j = 34353;
			sb = new StringBuilder();
			
			while (true) {
				first = true;
				flag = false;
				sb = new StringBuilder();
				sb.append("kWLinv(");
				Helpers.appendUsingFileOutputStream(fileReadByGAP, j + "\n");
				TimeUnit.SECONDS.sleep(1);
				groupInputStream = new FileInputStream("Stream2.txt");
				
				int y;
				byte[] buffer;
				
				do {
					buffer = new byte[1024];
					
					y = groupInputStream.read(buffer);
					sb.append(new String(buffer, "UTF-8"));
					
					if (first) {
						if (sb.charAt(7) != '[') {
							// numberOfGroupsHavingOrder = Integer.parseInt(sb.substring(7).toString().trim());
							flag = true;
							break;
						}
						
						first = false;
					}
					
				} while (y != -1);
				
				groupInputStream.close();

				if (!flag) {
					sb.append(");");
					parse(sb.toString(), i, j);
					j++;
				}
				else {
					System.out.println("Order " + i + " is done");
				}
			}
			
		}
		
		csvWriter.flush();
		csvWriter.close();
	}
	
	public static void compareTwo(int i, int j, int degree1, int degree2, int roundsParam, String CSVfileName, boolean printString) throws IOException, InterruptedException {
		globalCounter = 1;
		rounds = roundsParam;
		csvWriter = new FileWriter(CSVfileName);
		
		StringBuilder sb = new StringBuilder();
		sb.append("kWL(");
		String s = "Stream.txt";
		Helpers.appendUsingFileOutputStream(s, i + "\n");
		TimeUnit.SECONDS.sleep(1);
		FileInputStream is = new FileInputStream("Stream2.txt");

		int y;
		byte[] buffer;
			
		do {
			buffer = new byte[1024];
				
			y = is.read(buffer);
			sb.append(new String(buffer, "UTF-8"));
			
		} while (y != -1);
		is.close();
		sb.append(", ");
			
		Helpers.appendUsingFileOutputStream(s, j + "\n");
		TimeUnit.SECONDS.sleep(1);
		is = new FileInputStream("Stream2.txt");
		do {
			buffer = new byte[1024];
				
			y = is.read(buffer);
			sb.append(new String(buffer, "UTF-8"));
			
				
		} while (y != -1);
		is.close();
				
		sb.append(");");
		if (printString)
			System.out.println(sb.toString());
		parse(sb.toString(), degree1, degree2, i, j);

		csvWriter.flush();
		csvWriter.close();
	}
	
	public static void main(String[] args) throws IOException, InterruptedException {
//		globalCounter = 1;
//		rounds = 100000000;
//		csvWriter = new FileWriter("new2.csv");
//		
//		String s = "Stream.txt";
//		
//		Integer[] z = new Integer[] {175, 1132};
		
//		for (int i = 0; i < 5; i++) {
//			for (int j = 0; j < 5; j++) {
//				Helpers.appendUsingFileOutputStream(s, z[i] + "\n");
//				TimeUnit.SECONDS.sleep(1);
//				FileInputStream is = new FileInputStream("Stream2.txt");
//				StringBuilder sb = new StringBuilder();
//				int y;
//				sb.append("kWL(");
//				byte[] buffer;
//				
//				do {
//					buffer = new byte[1024];
//					
//					y = is.read(buffer);
//		            sb.append(new String(buffer, "UTF-8"));
//		            
//		        } while (y != -1);
//				
//				Helpers.appendUsingFileOutputStream(s, z[j] + "\n");
//				TimeUnit.SECONDS.sleep(1);
//				is = new FileInputStream("Stream2.txt");
//				sb.append(",");
//				
//				do {
//					buffer = new byte[1024];
//					
//					y = is.read(buffer);
//		            sb.append(new String(buffer, "UTF-8"));
//		            
//		        } while (y != -1);
//				is.close();
//				sb.append(")");
//				parse(sb.toString(), 128, 128, z[i], z[j]);
//			}
//		}
		
		genearateInvariants(256, 511, 1000000000, "new.csv", false);
		
//		ArrayList<Pair> array = new ArrayList<Pair>(Arrays.asList( new Pair(175, 1138), new Pair(164, 999), new Pair(166, 1014), new Pair(165, 1011),
//				new Pair(174, 177), new Pair(173, 1126), new Pair(167, 1013), new Pair(171, 1122), new Pair(1597, 1598), new Pair(831, 832),
//				new Pair(555, 556), new Pair(818, 819), new Pair(807, 808) ));
//		
//		for (Pair p : array) {
//			System.out.println("Groups " + p.id1 + " and " + p.id2);
//			compareTwo(p.id1, p.id2, 128, 128, 1000000000, "new2.csv", false);
//		}
	}
	
}
