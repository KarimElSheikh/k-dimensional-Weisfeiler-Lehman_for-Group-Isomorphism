package kWL;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.zip.CRC32;

import data.ArrayListOfData;
import data.Data;
import datastructure.IndexedTreeMap2;
import datastructure.IndexedTreeSet;
import group.data.InitialColour;
import group.data.Colour;
import group.data.GroupInvariant;

/**
 * Checking is basically a class that holds several method that served to test the invariant data
 * generated by the method genearateInvariants() (in the class 'kWLClass').
 * 
 * The 2 methods that each test the invariant data in its own way are checkForCollisions() and
 * checkForCollisions2().
 * 
 * @author Karim Elsheikh
 */
public class Checking {
	
	static int size;
	static ArrayListComparator arrayListComparator = new ArrayListComparator();
	
	/**
	 * Computes a crc32 hash from a file given as a path: the string argument filepath.
	 * 
	 * @param	filepath	a string that is the path to the file that is to be hashed.
	 * 
	 * @return	long		crc32 hash of the file in 'filepath'.
	 */
	public static long checksumInputStream(String filepath) throws IOException {
		
		InputStream inputStreamn = new FileInputStream(filepath);
		CRC32 crc = new CRC32();
		int cnt;
		
		while ((cnt = inputStreamn.read()) != -1) {
			crc.update(cnt);
		}
		
		inputStreamn.close();
		return crc.getValue();
	}
	
	/**
	 * Computes a crc32 hash from a file given as a path: the string argument filepath.
	 * This one used a BufferedInputStream and thus should (always?) be preferred.
	 * 
	 * @param	filepath	a string that is the path to the file that is to be hashed.
	 * 
	 * @return	long		crc32 hash of the file in 'filepath'.
	 */
	public static long checksumBufferedInputStream(String filepath) throws IOException {
		
		size = (int) Files.size(Paths.get(filepath));
		
		InputStream inputStream = new BufferedInputStream(new FileInputStream(filepath.toString()));
		CRC32 crc = new CRC32();
		int cnt;
		
		while ((cnt = inputStream.read()) != -1) {
			crc.update(cnt);
		}
		
		inputStream.close();
		return crc.getValue();
	}
	
	/**
	 * Computes a crc32 hash from a file given as a path: the string argument filepath.
	 * This one uses the class RandomAccessFile to read the file.
	 * 
	 * @param	filepath	a string that is the path to the file that is to be hashed.
	 * 
	 * @return	long		crc32 hash of the file in 'filepath'.
	 */
	public static long checksumRandomAccessFile(String filepath) throws IOException {
		
		RandomAccessFile randAccfile = new RandomAccessFile(filepath, "r");
		long length = randAccfile.length();
		CRC32 crc = new CRC32();
		for (long i = 0; i < length; i++) {
			randAccfile.seek(i);
			int cnt = randAccfile.readByte();
			crc.update(cnt);
		}
		
		randAccfile.close();
		return crc.getValue();
	}
	
	/**
	 * Computes a crc32 hash from a file given as a path: the string argument filepath.
	 * This one used the classes FileChannel and MappedByteBuffer to read the file.
	 * 
	 * @param	filepath	a string that is the path to the file that is to be hashed.
	 * 
	 * @return	long		crc32 hash of the file in 'filepath'.
	 */
	public static long checksumMappedFile(String filepath) throws IOException {
		
		FileInputStream inputStream = new FileInputStream(filepath);
		FileChannel fileChannel = inputStream.getChannel();
		int len = (int) fileChannel.size();
		MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, len);
		CRC32 crc = new CRC32();
		
		for (int cnt = 0; cnt < len; cnt++) {
			int i = buffer.get(cnt);
			crc.update(i);
		}
		
		inputStream.close();
		return crc.getValue();
	}
	
	/**
	 * This method works its way through the subfolder for the invariant data of each order in the
	 * interval [startOrder, maxOrder], for each group it gets the file size and the crc32 hash of
	 * the group's files (each group has 3 files for each round).
	 * Then an ArrayListOfData instance is created for the group that holds the group id along with the
	 * file size and hash information. They are sorted using a convenient comparison function such that
	 * if 2 groups have the same invariant data, their respective ArrayListOfData instances will be
	 * adjacent after sorting, and when comparing them they will be equal.
	 * We check for equality for every 2 adjacent ArrayListOfData and print the group ids.
	 */
	public static void checkForCollisions(int startOrder, int maxOrder) throws IOException {
		
		for (int order = startOrder; order <= maxOrder; order++) {
			System.out.println("order: " + order);
			AtomicInteger maxGroupID = new AtomicInteger(Integer.MIN_VALUE);
			
			Files.list(new File("Invariants\\" + order).toPath())
			.forEach(path -> {
				String pathString = path.toString();
				maxGroupID.set(Math.max(maxGroupID.get(), Integer.parseInt(pathString.substring(pathString.lastIndexOf("\\") + 1))));
			});
			
			ArrayList<ArrayListOfData> a = new ArrayList<ArrayListOfData>();
			int groups = maxGroupID.get();
			
			for (int j = 1; j <= groups; j++) {
				ArrayListOfData b = new ArrayListOfData(j);
				
				Files.list(new File("Invariants\\" + order + "\\" + j).toPath())
				.forEach(path -> {
					try {
						String pathString = path.toString();
						
						if (pathString.substring(pathString.lastIndexOf("\\") + 1).equals("#0")) {
							long crc32 = checksumBufferedInputStream(pathString + "\\C");
							b.array.add(new Data(size, crc32));
							crc32 = checksumBufferedInputStream(pathString + "\\numberOfColourClasses.txt");
							b.array.add(new Data(size, crc32));
							crc32 = checksumBufferedInputStream(pathString + "\\uniqueInitialColours");
							b.array.add(new Data(size, crc32));
						}
						else {
							long crc32 = checksumBufferedInputStream(pathString + "\\C");
							b.array.add(new Data(size, crc32));
							crc32 = checksumBufferedInputStream(pathString + "\\numberOfColourClasses.txt");
							b.array.add(new Data(size, crc32));
							crc32 = checksumBufferedInputStream(pathString + "\\uniqueColours");
							b.array.add(new Data(size, crc32));
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				});
				
				a.add(b);
			}
			
			Collections.sort(a);
			
			for (int i = 0; i < a.size() - 1; i++) {
				if (a.get(i).compareTo(a.get(i+1)) == 0) {
					System.out.println("2 undifferentiated Groups detected: " + a.get(i).id + " and " + (a.get(i+1).id) + "\n");
				}
			}
		}
	}
	
	/**
	 * Reads a serialised Java Object that was written to the hard drive and returns it.
	 * 
	 * @param	filepath	a string that is the path to the file that is to be read.
	 * 
	 * @return	Object		a java class instance that is simply casted as an "Object".
	 */
	public static Object ReadObjectFromFile(String filepath) {
		
		try {
			
			FileInputStream fileIn = new FileInputStream(filepath);
			ObjectInputStream objectIn = new ObjectInputStream(fileIn);
			
			Object obj = objectIn.readObject();
			
			objectIn.close();
			return obj;
			
		} catch (Exception ex) {
			ex.printStackTrace();
			return null;
		}
	}
	
	/**
	 * This method works pretty much mostly the same as checkForCollisions(), it works its way through the subfolder
	 * for the invariant data of each order in the interval [startOrder, maxOrder], for each group it reads all the
	 * files and casts them to the correct class.
	 * A GroupInvariant instance is created for each group. They are sorted using a convenient comparison function
	 * such that if 2 groups have the same invariant data, their respective GroupInvariant instances will be
	 * adjacent after sorting, and when comparing them they will be equal.
	 * We check for equality for every 2 adjacent ArrayListOfData and print the group ids.
	 */
	@SuppressWarnings("unchecked")
	public static void checkForCollisions2(int startOrder, int maxOrder) throws IOException {
		
		for (int order = startOrder; order <= maxOrder; order++) {
			System.out.println("order: " + order);
			AtomicInteger maxGroupID = new AtomicInteger(Integer.MIN_VALUE);
			
			Files.list(new File("Invariants\\" + order).toPath())
			.forEach(path -> {
				String pathString = path.toString();
				maxGroupID.set(Math.max(maxGroupID.get(), Integer.parseInt(pathString.substring(pathString.lastIndexOf("\\") + 1))));
			});
			
			int groups = maxGroupID.get();
			
			ArrayList<GroupInvariant> GIs = new ArrayList<GroupInvariant>();
			
			for (int j = 1; j <= groups; j++) {
				AtomicReference<IndexedTreeSet<InitialColour>> initialColours = new AtomicReference<>();
				ArrayList<Integer> numberOfColourClassesArray = new ArrayList<Integer>();
				ArrayList<IndexedTreeSet<Colour>> uniqueColoursArray = new ArrayList<IndexedTreeSet<Colour>>();
				ArrayList<IndexedTreeMap2<Integer>> colourCountsArray = new ArrayList<IndexedTreeMap2<Integer>>();
				AtomicInteger maxRound = new AtomicInteger(Integer.MIN_VALUE);
				
				Files.list(new File("Invariants\\" + order + "\\" + j).toPath())
				.forEach(path -> {
					try {
						String pathString = path.toString();
						maxRound.set(Math.max(maxGroupID.get(), Integer.parseInt(pathString.substring(pathString.lastIndexOf("\\") + 2))));
						
						if (pathString.substring(pathString.lastIndexOf("\\") + 1).equals("#0")) {
							colourCountsArray.add((IndexedTreeMap2<Integer>) ReadObjectFromFile(pathString + "\\C"));
							
							byte[] fileArray = Files.readAllBytes(Paths.get(pathString + "\\numberOfColourClasses.txt"));
							numberOfColourClassesArray.add(Integer.parseInt(new String(fileArray, 0, fileArray.length-2, "UTF-8")));
							
							initialColours.set((IndexedTreeSet<InitialColour>) ReadObjectFromFile(pathString + "\\uniqueInitialColours"));
						}
						else {
							colourCountsArray.add((IndexedTreeMap2<Integer>) ReadObjectFromFile(pathString + "\\C"));
							
							byte[] fileArray = Files.readAllBytes(Paths.get(pathString + "\\numberOfColourClasses.txt"));
							numberOfColourClassesArray.add(Integer.parseInt(new String(fileArray, 0, fileArray.length-2, "UTF-8")));
							
							uniqueColoursArray.add((IndexedTreeSet<Colour>) ReadObjectFromFile(pathString + "\\uniqueColours"));
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				});
				
				GroupInvariant gi = new GroupInvariant(j, order, maxRound.get(), initialColours.get(), numberOfColourClassesArray, uniqueColoursArray, colourCountsArray);
				GIs.add(gi);
			}
			
			Collections.sort(GIs);
			
			for (int i = 0; i < groups-1; i++) {
				if (GIs.get(i).equals(GIs.get(i+1))) {
					System.out.println("2 undifferentiated Groups detected: " + GIs.get(i).id + " and " + (GIs.get(i+1).id) + "\n");
				}
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		checkForCollisions(256, 256);
	}
	
}
