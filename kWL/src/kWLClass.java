import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import Colour.Colour;
import pair.Pair;
import datastructure.IndexedTreeSet;
import datastructure.IndexedTreeMap2;
import exceptions.InvalidPermutationException;

public class kWLClass {
	
	static int rounds;
	static int globalCounter;
	static ArrayListComparator arrayListComparator = new ArrayListComparator();
	
	/**
	 * Returns a Pair.
	 * The Pair contains ArrayList<Integer[]> genBy that stores for each
	 * element in the group a minimum sequence of generators that generate this element
	 * where the generators are prioritized in the order given.
	 * The generators are referred to as 1-based indices.
	 * The Pair additionally contains Integer[][] yield, that has (length of generators) many
	 * rows, and in each row there is (Order of group - 1) integers, which are the indices of
	 * elements that result from the multiplication of each element in the group
	 * (except the identity) by the ith generator.
	 * The elements are also referred to as 1-based indices.
	 * 
	 * generatedByAndYields below is the actual method used by this kWL implementation,
	 * the generators are passed as indices along with a reference to the whole group.
	 */
	public static Pair generatedByAndYields(Permutation[] generators, int degree) {
		TreeMap<Permutation, Integer> orbitMap = new TreeMap<Permutation, Integer>();
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		ArrayList<Integer[]> genBy = new ArrayList<Integer[]>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitMap.put(identity, 1);
		orbit.add(identity);
		genBy.add(new Integer[0]); // Integer array of length 0
		
		for (int i = 0; i < generators.length; i++) {
			orbit.add(generators[i]);
			orbitMap.put(generators[i], orbit.size());
			genBy.add(new Integer[] {i+1}); // Integer array containing only the 1-based index (i+1)
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (int j = 0; j < generators.length; j++) {
				t = orbit.get(i).multiply(generators[j]);
				if (!orbitMap.containsKey(t)) {
					orbit.add(t);
					orbitMap.put(t, orbit.size());
					genBy.add(Helpers.copyAndAdd(genBy.get(i), j+1)); // New element is generated by the sequence genBy[i] ○ (j+1)
				}
			}
		}
		
		Integer[][] yield = new Integer[generators.length][orbit.size()-1];
		for (int i = 0; i < generators.length; i++) {
			for (int j = 1; j < orbit.size(); j++) {
				yield[i][j-1] = orbitMap.get(orbit.get(j).multiply(generators[i]));
			}
		}
		
		return new Pair(genBy, yield);
	}
	
	/**
	 * Same as above, except it uses the ArrayList indices to access the generators from the group.
	 */
	public static Pair generatedByAndYields(Permutation[] group, ArrayList<Integer> indices, int degree) {
		TreeMap<Permutation, Integer> orbitMap = new TreeMap<Permutation, Integer>();
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		ArrayList<Integer[]> genBy = new ArrayList<Integer[]>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitMap.put(identity, 1);
		orbit.add(identity);
		genBy.add(new Integer[0]); // Integer array of length 0
		
		for (int i = 0; i < indices.size(); i++) {
			orbit.add(group[indices.get(i)]);
			orbitMap.put(group[indices.get(i)], orbit.size());
			genBy.add(new Integer[] {i+1}); // Integer array containing only the 1-based index (i+1)
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (int j = 0; j < indices.size(); j++) {
				t = orbit.get(i).multiply(group[indices.get(j)]);
				if (!orbitMap.containsKey(t)) {
					orbit.add(t);
					orbitMap.put(t, orbit.size());
					genBy.add(Helpers.copyAndAdd(genBy.get(i), j+1)); // New element is generated by the sequence genBy[i] ○ (j+1)
				}
			}
		}
		
		Integer[][] yield = new Integer[indices.size()][orbit.size()-1];
		for (int i = 0; i < indices.size(); i++) {
			for (int j = 1; j < orbit.size(); j++) {
				yield[i][j-1] = orbitMap.get(orbit.get(j).multiply(group[indices.get(i)]));
			}
		}
		
		return new Pair(genBy, yield);
	}
	
	/**
	 * Generates the whole group from the given array of generators.
	 */
	public static Permutation[] generate(Permutation[] generators, int degree) {
		TreeSet<Permutation> orbitSet = new TreeSet<Permutation>(); 
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitSet.add(identity);
		orbit.add(identity);
		
		for (Permutation s : generators) {
			orbitSet.add(s);
			orbit.add(s);
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (Permutation s : generators) {
				t = orbit.get(i).multiply(s);
				
				if (!orbitSet.contains(t)) {
					orbitSet.add(t);
					orbit.add(t);
				}
			}
		}
		
		return orbit.toArray(new Permutation[orbit.size()]);
	}
	
	public static boolean compareColours(IndexedTreeMap2<Integer> C1, IndexedTreeMap2<Integer> C2, int p, boolean converges) {
		NavigableSet<Integer> keySet1 = C1.navigableKeySet();
		NavigableSet<Integer> keySet2 = C2.navigableKeySet();
		
		if (keySet1.size() != keySet2.size()) {
			if (converges) {
				System.out.print("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
				   + "Colour sets don't have the same size");
			}
			else {
				System.out.print("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
		    	+ "Colour sets don't have the same size");
			}
		    System.out.println(" (" + keySet1.size() + " and " + keySet2.size() + ").");
		    return false;
		}
		
		if (!keySet1.equals(keySet2)) {
			if (converges) {
				System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size, but don't have the same colours.");
			}
			else {
				System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size, but don't have the same colours.");
			}
		    return false;
		}
		
		Iterator<Integer> it1 = keySet1.iterator();
		Iterator<Integer> it2 = keySet2.iterator();
		int cn = 1;
		while (it1.hasNext()) {
			Integer t1 = it1.next(), t2 = it2.next();
			
			if (!C1.get(t1).equals(C2.get(t2))) {
				if (converges) {
					System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, but Colours #" + cn + "'s counts are not equal.");
				}
				else {
					System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, but Colours #" + cn + "'s counts are not equal.");
				}
				return false;
			}
			
			cn++;
		}
		
		return true;
	}
	
	public static boolean kWL(Permutation[] S1, Permutation[] S2, int degree1, int degree2) {
		Permutation[] G1, G2;
		G1 = generate(S1, degree1);
		G2 = generate(S2, degree2);
		
		if (G1.length != G2.length) {
			System.out.println("Non-isomorphic: Orders of the two groups when fully generated are not equal.");
			System.out.println(G1.length + " and " + G2.length);
			return false;
		}
		int order = G1.length;
		int p = 0;
		
		// Maps from pair of indices to Pair (colour in Round 0)
		TreeMap<ArrayList<Integer>, Pair> E1 = new TreeMap<ArrayList<Integer>, Pair> (arrayListComparator);
		TreeMap<ArrayList<Integer>, Pair> E2 = new TreeMap<ArrayList<Integer>, Pair> (arrayListComparator);
		
		// Set containing all different Pairs, to allow mapping colours to integers
		IndexedTreeSet<Pair> uniquePairs = new IndexedTreeSet<Pair>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> C1 = new IndexedTreeMap2<Integer>();
		IndexedTreeMap2<Integer> C2 = new IndexedTreeMap2<Integer>();
		
		// Maps from pair of indices to colour index
		TreeMap<ArrayList<Integer>, Integer> M1 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
		TreeMap<ArrayList<Integer>, Integer> M2 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
		
		// Round 0
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				Pair X1 = generatedByAndYields(G1, A1, degree1);
				Pair X2 = generatedByAndYields(G2, A2, degree2);
				
				uniquePairs.add(X1);
				uniquePairs.add(X2);
				
				E1.put(A1, X1);
				E2.put(A2, X2);
			}
		}
		
		for (int i = 1; i < order; i++) {
			for (int j = 1; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				Pair X1 = E1.get(A1);
				Pair X2 = E2.get(A2);
				
				Integer t1 = uniquePairs.entryIndex(X1);
				Integer t2 = uniquePairs.entryIndex(X2);
				
				C1.increment(t1);
				C2.increment(t2);
				
				M1.put(A1, t1);
				M2.put(A2, t2);
			}
		}
		// End of Round 0
		
		System.out.println("Round " + 0 + ":");
		System.out.println("Number of Colour Classes: " + uniquePairs.size());
		if (!compareColours(C1, C2, p, false))
			return false;
		
		// Maps from pair of indices to Colour (colour starting from Round 1)
		TreeMap<ArrayList<Integer>, Colour> F1 = new TreeMap<ArrayList<Integer>, Colour> (arrayListComparator);
		TreeMap<ArrayList<Integer>, Colour> F2 = new TreeMap<ArrayList<Integer>, Colour> (arrayListComparator);
		
		// Set containing all different Colours, to allow mapping Colours to integers
		IndexedTreeSet<Colour> uniqueColours = new IndexedTreeSet<Colour>();
		
		// Maps the old colour's index to the new colour's index, used to check convergence
		TreeMap<Integer, Integer> colourIndexToIndex1 = new TreeMap<Integer, Integer>();
		TreeMap<Integer, Integer> colourIndexToIndex2 = new TreeMap<Integer, Integer>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		// Multisets of the >new< colours in each group, where the colours are referred to by integers
		IndexedTreeMap2<Integer> D1;
		IndexedTreeMap2<Integer> D2;
		
		// Maps from pair of indices to >new< colour index
		TreeMap<ArrayList<Integer>, Integer> N1;
		TreeMap<ArrayList<Integer>, Integer> N2;
		
		boolean converges1 = false;
		boolean converges2 = false;
		
		// Start of Rounds ≥ 1
		for (p = 1; p <= rounds; p++) {
			converges1 = true;
			converges2 = true;
			
			D1 = new IndexedTreeMap2<Integer>();
			D2 = new IndexedTreeMap2<Integer>();
			N1 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);
			N2 = new TreeMap<ArrayList<Integer>, Integer> (arrayListComparator);

			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					// IndexedTreeMap<Integer, Integer> with increment
					IndexedTreeMap2<Integer> t1 = new IndexedTreeMap2<Integer>();
					IndexedTreeMap2<Integer> t2 = new IndexedTreeMap2<Integer>();
					for (int k = 1; k < order; k++) {
						if (k != i && k != j) {
							ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(k, j));
							ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, k));
							t1.increment(M1.get(A1));
							t1.increment(M1.get(A2));
							t2.increment(M2.get(A1));
							t2.increment(M2.get(A2));
						}
					}
					ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
					ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Colour c1 = new Colour(M1.get(A1), t1);
					Colour c2 = new Colour(M2.get(A2), t2);
					
					F1.put(A1, c1);
					F2.put(A2, c2);
					
					uniqueColours.add(c1);
					uniqueColours.add(c2);
				}
			}
			
			for (int i = 1; i < order; i++) {
				for (int j = 1; j < order; j++) {
					if (i == j)
						continue;
					
					ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
					ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Integer c1_index = uniqueColours.entryIndex(F1.get(A1));
					Integer c2_index = uniqueColours.entryIndex(F2.get(A2));
					
					if (converges1) {
						Integer temp = colourIndexToIndex1.put(M1.get(A1), c1_index);
						if (temp != null && temp != c1_index)
							converges1 = false;
					}
					if (converges2) {
						Integer temp = colourIndexToIndex2.put(M2.get(A2), c2_index);
						if (temp != null && temp != c2_index)
							converges2 = false;
					}
					
					N1.put(A1, c1_index);
					N2.put(A2, c2_index);
					D1.increment(c1_index);
					D2.increment(c2_index);
				}
			}
			
			System.out.println("Round " + p + ":");
			System.out.println("Number of Colour Classes: " + uniqueColours.size());
			
			if (!compareColours(D1, D2, p, converges1 && converges2))
				return false;
			
			// Cleanup at the end of a round
			colourIndexToIndex1.clear();
			colourIndexToIndex2.clear();
			uniqueColours.clear();
			
			M1.clear();
			M2.clear();
			M1 = N1; // new colours will now be the old colours
			M2 = N2;
			
			C1.clear();
			C2.clear();
			C1 = D1; // new colours will now be the old colours
			C2 = D2;
			
			F1.clear();
			F2.clear();
			if (converges1 && converges2)
				break;
		}
		// End of Rounds ≥ 1
		
		if (!converges1 || !converges2)
			p--;
		
		if (converges1 && converges2) {
			System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		else {
			System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		
		return true;
	}
	
	public static void parseKWL(String s, int degree1, int degree2) {
		int i = 3;
		boolean error = false;
		while (true) {
			if (s.charAt(i) =='(') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
				error = true;
				break;
			}
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		i++;
		
		while (true) {
			if (s.charAt(i) =='[') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		i++;
		
		int h = i;
		ArrayList<Permutation> a = new ArrayList<Permutation>();
		ArrayList<Permutation> b = new ArrayList<Permutation>();
		int processingInteger = 0;
		boolean processingPerm = false;
		boolean foundOpeningBracket = false;
		boolean doneWithFirstGroup = false;
		
		while (true) {
			if (!foundOpeningBracket) {
				if (s.charAt(i) == '(') {
					foundOpeningBracket = true;
					if (!processingPerm) { // h holds the index of the start of a permutation
						h = i;
						processingPerm = true;
					}
				}
				else if (s.charAt(i) == ',') {
					// For testing
//					System.out.println(h + " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s, h, i, degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s, h, i, degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) == ']') {
					// For testing
//					System.out.println(h + " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s, h, i, degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						doneWithFirstGroup = true;
						Pattern pattern = Pattern.compile("[ \t]*,[ \t]*\\[");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end() - 1;
						}
						else {
							error = true;
							break;
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s, h, i, degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						Pattern pattern = Pattern.compile("[ \t]*\\)[ \t]*;?[ \t]*");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end();
							if (i != s.length())
								error = true;
							break;
						}
						else {
							error = true;
							break;
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 0) { // Didn't start processing integer
				if (Character.isDigit(s.charAt(i))) {
					processingInteger = 1;
				}
				else if (s.charAt(i) == ')') {
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 1) { // Started processing integer
				if (Character.isDigit(s.charAt(i))) {
					
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t') {
					processingInteger = 2;
				}
				else {
					error = true;
					break;
				}
			}
			else if (processingInteger == 2) { // Whitespaces after integer
				if (Character.isDigit(s.charAt(i))) {
					error = true;
					break;
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t') {
					
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else {
					error = true;
					break;
				}
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		
//		System.out.println("Done");
//		System.out.println(a.size());
//		System.out.println(b.size());
//		for (Permutation x : b) {
//			Representation.printCyclic(x);
//		}
		
		kWL(a.toArray(new Permutation[a.size()]), b.toArray(new Permutation[b.size()]), degree1, degree2);
	}
	
	public static void parse(String s, int degree1, int degree2) {
		System.out.println("Task #" + globalCounter++);
		if (s.length() <= 2) {
			System.out.println("Error: String format is incorrect");
			System.out.println();
			return;
		}
		
		if (s.substring(0, 3).equalsIgnoreCase("kWL")) {
			parseKWL(s, degree1, degree2);
			System.out.println();
		}
	}
	
	// Any amount of spaces or tab spaces is (should be) allowed.
	// One semicolon is optional
	public static void main(String[] args) {
		globalCounter = 1;
		rounds = 7;
		
//		Dihedral Group of Order 8, Dihedral Group of Order 8 (renamed)
		parse("kWL([ (1,2,3,4), (2,4) ],[(5,3,8,6),(3,6)]);", 4, 8);
//		Dihedral Group of Order 8, DihedralGroup of Order 8 (swapping the generators)
		parse("kWL([ (1,2,3,4), (2,4) ],[(3  ,  6), ( 5	,		3,8,6)])", 4, 8);
//		Dihedral Group of Order 8, Quaternion Group of Order 8
		parse("kWL([ (1,2,3,4), (2,4) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]);", 4, 8);
//		Quaternion Group of Order 8, Quaternion Group of Order 8
		parse("kWL([ (6,22,14,30)(10,34,18,26), (6,10,14,18)(22,26,30,34) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]) 	", 34, 8);
//		Dihedral Group of Order 8, Cyclic Group of Order 8		
		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2,3,4,5,6,7,8) ]);", 4, 8);
//		Dihedral Group of Order 8, Z_4 x Z_2	
		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2,3,4), (5,6) ]);", 4, 6);
//		Dihedral Group of Order 8, Elementary Abelian Group of order 8
		parse("kWL([ (1,2,3,4), (2,4) ],[ (1,2), (3,4), (5,6) ]);", 4, 6);
	}
	
}
