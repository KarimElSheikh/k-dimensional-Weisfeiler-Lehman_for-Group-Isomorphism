import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import Colour.Colour;
import pair.Pair;
import datastructure.IndexedTreeMap3;
import datastructure.IndexedTreeSet;
import exceptions.InvalidPermutationException;

public class kWLClass {
	
	static int rounds;
	static int globalCounter;
	
	/**
	 * Returns a Pair.
	 * The Pair contains ArrayList<Integer[]> genBy that stores for each
	 * element in the group a minimum sequence of generators that generate this element
	 * where the generators are prioritized in the order given.
	 * The elements are referred to as 1-based indices in yield (explained below).
	 * The Pair additionally contains Integer[][] yield, that has (length of generators) many
	 * rows, and in each row there is (Order of group - 1) integers, which are the indices of
	 * elements that result from the multiplication of each element in the group
	 * (except the identity) by the ith generator.
	 */
	public static Pair generatedByAndYields(Permutation[] generators, int degree) {
		TreeMap<Permutation, Integer> orbitMap = new TreeMap<Permutation, Integer>();
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		ArrayList<Integer[]> genBy = new ArrayList<Integer[]>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitMap.put(identity, 1);
		orbit.add(identity);
		genBy.add(new Integer[0]); // Integer array of length 0
		
		for (int i = 0; i < generators.length; i++) {
			orbit.add(generators[i]);
			orbitMap.put(generators[i], orbit.size());
			genBy.add(new Integer[] {i+1}); // Integer array containing only the element (i+1)
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (int j = 0; j < generators.length; j++) {
				t = orbit.get(i).multiply(generators[j]);
				if (!orbitMap.containsKey(t)) {
					orbit.add(t);
					orbitMap.put(t, orbit.size());
					genBy.add(Helpers.copyAndAdd(genBy.get(i), j+1)); // New element is generated by the sequence genBy[i] â—‹ (j+1)
				}
			}
		}
		
		Integer[][] yield = new Integer[generators.length][orbit.size()-1];
		for (int i = 0; i < generators.length; i++) {
			for (int j = 1; j < orbit.size(); j++) {
				yield[i][j-1] = orbitMap.get(orbit.get(j).multiply(generators[i]));
			}
		}
		
		return new Pair(genBy, yield);
	}
	
	public static Permutation[] generate(Permutation[] generators, int degree) {
		TreeSet<Permutation> orbitSet = new TreeSet<Permutation>(); 
		ArrayList<Permutation> orbit = new ArrayList<Permutation>();
		
		Permutation identity = Permutation.identityPermutation(degree);
		orbitSet.add(identity);
		orbit.add(identity);
		
		for (Permutation s : generators) {
			orbitSet.add(s);
			orbit.add(s);
		}
		
		Permutation t;
		for (int i = 1; i < orbit.size(); i++) {
			for (Permutation s : generators) {
				t = orbit.get(i).multiply(s);
				
				if (!orbitSet.contains(t)) {
					orbitSet.add(t);
					orbit.add(t);
				}
			}
		}
		
		return orbit.toArray(new Permutation[orbit.size()]);
	}
	
	public static boolean compareColours(IndexedTreeMap3 C1, IndexedTreeMap3 C2, int p, boolean converges) {
		NavigableSet<Integer> keySet1 = C1.navigableKeySet();
		NavigableSet<Integer> keySet2 = C2.navigableKeySet();
		
		if (keySet1.size() != keySet2.size()) {
			if (converges) {
				System.out.print("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
				   + "Colour sets don't have the same size");
			}
			else {
				System.out.print("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
		    	+ "Colour sets don't have the same size");
			}
		    System.out.println(" (" + keySet1.size() + " and " + keySet2.size() + ").");
		    return false;
		}
		
		if (!keySet1.equals(keySet2)) {
			if (converges) {
				System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size, but don't have the same colours.");
			}
			else {
				System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
					+ "Colour sets have the same size, but don't have the same colours.");
			}
		    return false;
		}
		
		Iterator<Integer> it1 = keySet1.iterator();
		Iterator<Integer> it2 = keySet2.iterator();
		int cn = 1;
		while (it1.hasNext()) {
			Integer t1 = it1.next(), t2 = it2.next();
			
			if (!C1.get(t1).equals(C2.get(t2))) {
				if (converges) {
					System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, and Colours #" + cn + " are the same but their counts are not equal.");
				}
				else {
					System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: Non-isomorphic\n"
						+ "Colour sets have the same colours, and Colours #" + cn + " are the same but their counts are not equal.");
				}
				return false;
			}
			
			cn++;
		}
		
		return true;
	}
	
	public static boolean kWL(Permutation[] S1, Permutation[] S2, int degree1, int degree2) {
		Permutation[] G1, G2;
		G1 = generate(S1, degree1);
		G2 = generate(S2, degree2);
		
		if (G1.length != G2.length) {
			System.out.println("Non-isomorphic: Orders of the two groups when fully generated are not equal.");
			System.out.println(G1.length + " and " + G2.length);
			return false;
		}
		int order = G1.length;
		int p = 0;
		
		IndexedTreeSet<Pair> B = new IndexedTreeSet<Pair>();
		
		// IndexedTreeMap<Integer, Integer> with increment
		IndexedTreeMap3 C1 = new IndexedTreeMap3();
		IndexedTreeMap3 C2 = new IndexedTreeMap3();
		
		TreeMap<ArrayList<Integer>, Integer> M1 = new TreeMap<ArrayList<Integer>, Integer> (new ArrayListComparator());
		TreeMap<ArrayList<Integer>, Integer> M2 = new TreeMap<ArrayList<Integer>, Integer> (new ArrayListComparator());
		
		TreeMap<ArrayList<Integer>, Pair> H1 = new TreeMap<ArrayList<Integer>, Pair> (new ArrayListComparator());
		TreeMap<ArrayList<Integer>, Pair> H2 = new TreeMap<ArrayList<Integer>, Pair> (new ArrayListComparator());
		
		for (int i = 0; i < order; i++) {
			for (int j = 0; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				Pair X1 = generatedByAndYields(new Permutation[] {G1[i], G1[j]}, degree1);
				Pair X2 = generatedByAndYields(new Permutation[] {G2[i], G2[j]}, degree2);
				
				B.add(X1);
				B.add(X2);
				
				H1.put(A1, X1);
				H2.put(A2, X2);
			}
		}
		
		for (int i = 0; i < order; i++) {
			for (int j = 0; j < order; j++) {
				if (i == j)
					continue;
				
				ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
				ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
				
				Pair X1 = H1.get(A1);
				Pair X2 = H2.get(A2);
				
				Integer t1 = B.entryIndex(X1);
				Integer t2 = B.entryIndex(X2);
				
				C1.increment(t1);
				C2.increment(t2);
				
				M1.put(A1, t1);
				M2.put(A2, t2);
			}
		}
		
		if (!compareColours(C1, C2, p, false))
			return false;
		
		// IndexedTree<Integer, Integer>
		IndexedTreeMap3 D1;
		IndexedTreeMap3 D2;
		
		TreeMap<ArrayList<Integer>, Colour> F1 = new TreeMap<ArrayList<Integer>, Colour> (new ArrayListComparator());
		TreeMap<ArrayList<Integer>, Colour> F2 = new TreeMap<ArrayList<Integer>, Colour> (new ArrayListComparator());

		TreeMap<ArrayList<Integer>, Integer> N1;
		TreeMap<ArrayList<Integer>, Integer> N2;
		
		TreeMap<Integer, Integer> E = new TreeMap<Integer, Integer>();
		IndexedTreeSet<Colour> Y = new IndexedTreeSet<Colour>();
		
		boolean converges = false;
		System.out.println("Round " + 0 + ":");
		System.out.println("Number of Colour Classes: " + B.size());
		
		for (p = 1; p <= rounds; p++) {
			converges = true;
			
			D1 = new IndexedTreeMap3();
			D2 = new IndexedTreeMap3();
			N1 = new TreeMap<ArrayList<Integer>, Integer> (new ArrayListComparator());
			N2 = new TreeMap<ArrayList<Integer>, Integer> (new ArrayListComparator());

			for (int i = 0; i < order; i++) {
				for (int j = 0; j < order; j++) {
					if (i == j)
						continue;
					
					// IndexedTreeMap<Integer, Integer> with increment
					IndexedTreeMap3 t1 = new IndexedTreeMap3();
					IndexedTreeMap3 t2 = new IndexedTreeMap3();
					for (int k = 0; k < order; k++) {
						if (k != i && k != j) {
							ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(k, j));
							ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, k));
							t1.increment(M1.get(A1));
							t1.increment(M1.get(A2));
							t2.increment(M2.get(A1));
							t2.increment(M2.get(A2));
						}
					}
					ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
					ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Integer c1_oldIndex = M1.get(A1);
					Integer c2_oldIndex = M2.get(A2);
					
					Colour c1 = new Colour(c1_oldIndex, t1);
					Colour c2 = new Colour(c2_oldIndex, t2);
					
					F1.put(A1, c1);
					F2.put(A2, c2);
					
					Y.add(c1);
					Y.add(c2);
				}
			}
			
			for (int i = 0; i < order; i++) {
				for (int j = 0; j < order; j++) {
					if (i == j)
						continue;
					
					ArrayList<Integer> A1 = new ArrayList<Integer> (Arrays.asList(i, j));
					ArrayList<Integer> A2 = new ArrayList<Integer> (Arrays.asList(i, j));
					
					Integer c1_oldIndex = M1.get(A1);
					Integer c2_oldIndex = M2.get(A2);
					
					Integer c1_index = Y.entryIndex(F1.get(A1));
					Integer c2_index = Y.entryIndex(F2.get(A2));
					
					Integer temp = E.put(c1_oldIndex, c1_index);
					if (converges && temp != null && temp != c1_index) {
						converges = false;
					}
					temp = E.put(c2_oldIndex, c2_index);
					if (converges && temp != null && temp != c2_index) {
						converges = false;
					}
					
					N1.put(A1, c1_index);
					N2.put(A2, c2_index);
					D1.increment(c1_index);
					D2.increment(c2_index);
				}
			}
			
			System.out.println("Round " + p + ":");
			System.out.println("Number of Colour Classes: " + Y.size());
			
			if (!compareColours(D1, D2, p, converges))
				return false;
			
			// Cleanup at the end of a round
			E.clear();
			Y.clear();
			
			M1.clear();
			M2.clear();
			M1 = N1;
			M2 = N2;
			
			C1.clear();
			C2.clear();
			C1 = D1;
			C2 = D2;
			
			F1.clear();
			F2.clear();
			if (converges)
				break;
		}
		
		if (!converges)
			p--;
		
		if (converges) {
			System.out.println("Verdict after converging in round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		else {
			System.out.println("Verdict after round " + p + " of 2-dim Weisfeiler-Lehman: No difference was detected (Isomorphic?).");
		}
		
		return true;
	}
	
	public static void parseKWL(String s, int degree1, int degree2) {
		int i = 3;
		boolean error = false;
		while (true) {
			if (s.charAt(i) =='(') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
				error = true;
				break;
			}
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		i++;
		
		while (true) {
			if (s.charAt(i) =='[') {
				break;
			}
			else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
				error = true;
				break;
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		i++;
		
		int h = i;
		ArrayList<Permutation> a = new ArrayList<Permutation>();
		ArrayList<Permutation> b = new ArrayList<Permutation>();
		int processingInteger = 0;
		boolean processingPerm = false;
		boolean foundOpeningBracket = false;
		boolean doneWithFirstGroup = false;
		
		while (true) {
			if (!foundOpeningBracket) {
				if (s.charAt(i) == '(') {
					foundOpeningBracket = true;
					if (!processingPerm) { // h holds the index of the start of a permutation
						h = i;
						processingPerm = true;
					}
				}
				else if (s.charAt(i) == ',') {
					// For testing
//					System.out.println(h + " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s.substring(h, i), degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s.substring(h, i), degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) == ']') {
					// For testing
//					System.out.println(h + " - " + i);
					if (!doneWithFirstGroup) {
						try {
							a.add(Representation.parsePermutation(s.substring(h, i), degree1));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						doneWithFirstGroup = true;
						Pattern pattern = Pattern.compile("[ \t]*,[ \t]*\\[");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end() - 1;
						}
						else {
							error = true;
							break;
						}
					}
					else {
						try {
							b.add(Representation.parsePermutation(s.substring(h, i), degree2));
						}
						catch (InvalidPermutationException e) {
							System.out.println(e.getMessage());
						}
						
						Pattern pattern = Pattern.compile("[ \t]*\\)[ \t]*;?[ \t]*");
						Matcher m = pattern.matcher(s);
						if (m.find(i+1)) {
							i = m.end();
							if (i != s.length())
								error = true;
							break;
						}
						else {
							error = true;
							break;
						}
					}
					
					processingPerm = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 0) { // Didn't start processing integer
				if (Character.isDigit(s.charAt(i))) {
					processingInteger = 1;
				}
				else if (s.charAt(i) == ')') {
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) != ' ' && s.charAt(i) != '\t') {
					error = true;
					break;
				}
			}
			else if (processingInteger == 1) { // Started processing integer
				if (Character.isDigit(s.charAt(i))) {
					
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t') {
					processingInteger = 2;
				}
				else {
					error = true;
					break;
				}
			}
			else if (processingInteger == 2) { // Whitespaces after integer
				if (Character.isDigit(s.charAt(i))) {
					error = true;
					break;
				}
				else if (s.charAt(i) == ',') {
					processingInteger = 0;
				}
				else if (s.charAt(i) == ' ' || s.charAt(i) == '\t') {
					
				}
				else if (s.charAt(i) == ')') {
					processingInteger = 0;
					foundOpeningBracket = false;
				}
				else {
					error = true;
					break;
				}
			}
			
			i++;
			if (i == s.length()) {
				error = true;
				break;
			}
		}
		if (error) {
			System.out.println("Error: String format is incorrect");
			return;
		}
		
//		System.out.println("Done");
//		System.out.println(a.size());
//		System.out.println(b.size());
//		for (Permutation x : b) {
//			Representation.printCyclic(x);
//		}
		
		kWL(a.toArray(new Permutation[a.size()]), b.toArray(new Permutation[b.size()]), degree1, degree2);
	}
	
	public static void parse(String s, int degree1, int degree2) {
		System.out.println("Task #" + globalCounter++);
		if (s.length() <= 2) {
			System.out.println("Error: String format is incorrect");
			System.out.println();
			return;
		}
		
		if (s.substring(0, 3).equalsIgnoreCase("kWL")) {
			parseKWL(s, degree1, degree2);
			System.out.println();
		}
	}
	
	// Any amount of spaces or tab spaces is (should be) allowed.
	public static void main(String[] args) {
		globalCounter = 1;
		rounds = 7;
		
//		DihedralGroup of Order 8, DihedralGroup of Order 8 (renamed)
		parse("kWL([ (1,2,3,4), (2,4) ],[(5,3,8,6),(3,6)]);", 4, 8);
//		DihedralGroup of Order 8, DihedralGroup of Order 8 (swapping the generators)
		parse("kWL([ (1,2,3,4), (2,4) ],[(3  ,  6), ( 5	,		3,8,6)]);", 4, 8);
//		DihedralGroup of Order 8, QuaternionGroup of Order 8
		parse("kWL([ (1,2,3,4), (2,4) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]);", 4, 8);
//		QuaternionGroup of Order 8, QuaternionGroup of Order 8
		parse("kWL([ (6,22,14,30)(10,34,18,26), (6,10,14,18)(22,26,30,34) ], [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]);", 34, 8);
	}
	
}
